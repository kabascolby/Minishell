/* int32_t	is_spchar(t_shell *s, sc_fptr *ddollard_fptr)
{
	int32_t		*i;
	t_bool		is_q;
	t_bool		is_dq;

	is_q = 0;
	is_dq = 0;
	i = (int32_t[2]){-1, -1};
	while (s->dstr->buff[++i[0]])
	{
		if (CE_(s->dstr->buff[i[0]], '$') && (i[1] = i[0]) >= 0)
		{
			s->dstr->buff[i[0] + 1] == '$' ?
			*ddollard_fptr = ddollard_handler : 0;
			break ;
		}
		if (CE_(s->dstr->buff[i[0]], 34) && !is_q &&
		!(i[0] && CE_(s->dstr->buff[i[0] - 1], 92)))
			is_dq = is_dq ^ 1;
		if (CE_(s->dstr->buff[i[0]], 39) && !is_dq &&
		!(i[0] && CE_(s->dstr->buff[i[0] - 1], 92)))
			is_q = is_q ^ 1;
		if (CE_(s->dstr->buff[i[0]], '#') && !is_q &&
		!is_dq && (i[1] = i[0]) >= 0)
			break ;
	}
	return (i[1]);
} */

	// ft_printf("----> s->dstr->buff = %s\n", s->dstr->buff);
	// printf("%d | %d\n", i[0], i[1]);

/*
** get the index of a special charactere, from that get the value
** of the special charactere in the spchar array.
** once the we got the value we can jump to the right function from
** the jumping table
*/

void	special_char_converter(t_shell *s)
{
	sc_fptr	*fptr;
	// sc_fptr			quote_fptr;
	int32_t			i;
	int8_t			idx;

	i = -1;
	// quote_fptr = dollard_handler;
	// while ((idx = is_spchar(s, &quote_fptr)) != -1)
	// {
	// 	fptr[(int8_t)g_spchar[(int8_t)s->dstr->buff[idx]]](s, idx);
	// }



// void	unhandled_spchar(t_shell *s, int *idx)
// {
// 	(void)s;
// 	(void)idx;
// }

/* char	**split_line(t_shell *s)
{
	char		**tokens;
	char		**tmp;
	uint16_t	bufsize;
	uint16_t	i;
	s->filters = (char[]){FILTERS};
	bufsize = TOK_BUFSIZE;
	tokens = MALLOC(bufsize * sizeof(char *));
	i = -1;
	while ((tokens[++i] = token_handler(s, s->dstr->buff, s->filters, &s->dstr->buff)) != 0)
	{
		if (i + 1 >= bufsize)
		{
			tmp = MALLOC((bufsize + TOK_BUFSIZE) * sizeof(char *));
			ft_memcpy((char **)tmp, (char **)tokens, bufsize * sizeof(char *));
			bufsize += TOK_BUFSIZE;
			FREE(tokens);
			tokens = tmp;
			tmp = NULL;
		}
	}
	tokens[i] = NULL;
	return (tokens);
} */

-----------------------------split line-------------------------

// int get_token(char *s, const char *filter, char **save_ptr)
// {
// 	if(s == NULL)
// 		s = *save_ptr;
// 	if(*s == '\0')
// 	{
// 		*save_ptr = s;
// 		return (NULL);
// 	}
// 	return ft_strspn(line, filter);
// }

// t_command	*command_handler(char *buff, t_command **h)
// {
// 	t_command *new_command;
// 	t_command *tmp;
// 	if (!buff || !*buff)
// 		return (h);
// 	new_command = MALLOC(sizeof(t_command));
// 	*h = new_command;
// 	while()

// }

// char *tokenizer()

// else
// 	{
// 		tmp = *h;
// 		while(tmp && tmp->next)
// 			tmp = tmp->next;
// 		tmp->next = new_command;
// 	}

if (s->is_quote && !((num > 1) && CE_(dstr_get(s->dstr, num - 1), 92)))
			s->is_quote = s->is_quote ^ 1;

const static char g_spchar[UINT8_MAX] =
{
	['$'] = 1,['#'] = 2, [34] = 3,
	[39] = 3, [92] = 4, [' '] = 5,
	['\t'] = 5, ['\f'] = 5,
	['\n'] = 5, ['\r'] = 5
};

const static char index_char[UINT8_MAX] =
{
	[9] = 1, [10] = 2, [27] = 3,
	[34] = 4, [39] = 4, [127] = 5
};

if (s->isquote == c || !s->isquote)
		s->isquote = !s->isquote ? c : 0;

dprintf(fd_num("/dev/ttys001"), "index--> %d| c = %d|\n",
	*idx, s->dstr->buff[*idx]);
dprintf(fd_num("/dev/ttys001"), "next--> %d| c--> %d | toadd-->%s|\n",
	next, (int)s->dstr->buff[*idx + next + 1], &s->dstr->buff[*idx + next + 1]);

// ft_printf("_____child_____________%d___%d\n", getpid(), p);
// ft_printf("________________parent________%d___%d\n", getpid(), p);

/* static char	*find_exec(t_hashtable *ht, char *name)
{
	char	*env_paths;
	char	*save_ptr;
	char	*tmp;
	t_entry *e;

	if (!(e = ht->get_entry(ht, "PATH")) || !e->item)
		return (NULL);
	tmp = NULL;
	save_ptr = NULL;
	env_paths = ft_strdup(e->item);
	save_ptr = env_paths;
	while ((tmp = ft_strtok_r(save_ptr, ":", &save_ptr)))
	{
		// dprintf(fd_num("/dev/ttys001"), "tmp->%s|s-->%s\n",tmp, save_ptr);
		if (!access((tmp = ft_join_args("", tmp, "/", name, 0)), F_OK | X_OK))
			break ;
	}
	free(env_paths);
	return (tmp);
} */

static t_bool		is_exectuble(char *path)
{
	struct stat sb;

	if (stat(path, &sb) == 0 && sb.st_mode & S_IXUSR)
		return (true);
	return (false);
}