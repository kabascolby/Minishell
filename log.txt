/* int32_t	is_spchar(t_shell *s, sc_fptr *ddollard_fptr)
{
	int32_t		*i;
	t_bool		is_q;
	t_bool		is_dq;

	is_q = 0;
	is_dq = 0;
	i = (int32_t[2]){-1, -1};
	while (s->dstr->buff[++i[0]])
	{
		if (CE_(s->dstr->buff[i[0]], '$') && (i[1] = i[0]) >= 0)
		{
			s->dstr->buff[i[0] + 1] == '$' ?
			*ddollard_fptr = ddollard_handler : 0;
			break ;
		}
		if (CE_(s->dstr->buff[i[0]], 34) && !is_q &&
		!(i[0] && CE_(s->dstr->buff[i[0] - 1], 92)))
			is_dq = is_dq ^ 1;
		if (CE_(s->dstr->buff[i[0]], 39) && !is_dq &&
		!(i[0] && CE_(s->dstr->buff[i[0] - 1], 92)))
			is_q = is_q ^ 1;
		if (CE_(s->dstr->buff[i[0]], '#') && !is_q &&
		!is_dq && (i[1] = i[0]) >= 0)
			break ;
	}
	return (i[1]);
} */

	// ft_printf("----> s->dstr->buff = %s\n", s->dstr->buff);
	// printf("%d | %d\n", i[0], i[1]);

/*
** get the index of a special charactere, from that get the value
** of the special charactere in the spchar array.
** once the we got the value we can jump to the right function from
** the jumping table
*/

void	special_char_converter(t_shell *s)
{
	sc_fptr	*fptr;
	// sc_fptr			quote_fptr;
	int32_t			i;
	int8_t			idx;

	i = -1;
	// quote_fptr = dollard_handler;
	// while ((idx = is_spchar(s, &quote_fptr)) != -1)
	// {
	// 	fptr[(int8_t)g_spchar[(int8_t)s->dstr->buff[idx]]](s, idx);
	// }



// void	unhandled_spchar(t_shell *s, int *idx)
// {
// 	(void)s;
// 	(void)idx;
// }

/* char	**split_line(t_shell *s)
{
	char		**tokens;
	char		**tmp;
	uint16_t	bufsize;
	uint16_t	i;
	s->filters = (char[]){FILTERS};
	bufsize = TOK_BUFSIZE;
	tokens = MALLOC(bufsize * sizeof(char *));
	i = -1;
	while ((tokens[++i] = token_handler(s, s->dstr->buff, s->filters, &s->dstr->buff)) != 0)
	{
		if (i + 1 >= bufsize)
		{
			tmp = MALLOC((bufsize + TOK_BUFSIZE) * sizeof(char *));
			ft_memcpy((char **)tmp, (char **)tokens, bufsize * sizeof(char *));
			bufsize += TOK_BUFSIZE;
			FREE(tokens);
			tokens = tmp;
			tmp = NULL;
		}
	}
	tokens[i] = NULL;
	return (tokens);
} */

-----------------------------split line-------------------------

// int get_token(char *s, const char *filter, char **save_ptr)
// {
// 	if(s == NULL)
// 		s = *save_ptr;
// 	if(*s == '\0')
// 	{
// 		*save_ptr = s;
// 		return (NULL);
// 	}
// 	return ft_strspn(line, filter);
// }

// t_command	*command_handler(char *buff, t_command **h)
// {
// 	t_command *new_command;
// 	t_command *tmp;
// 	if (!buff || !*buff)
// 		return (h);
// 	new_command = MALLOC(sizeof(t_command));
// 	*h = new_command;
// 	while()

// }

// char *tokenizer()

// else
// 	{
// 		tmp = *h;
// 		while(tmp && tmp->next)
// 			tmp = tmp->next;
// 		tmp->next = new_command;
// 	}

if (s->is_quote && !((num > 1) && CE_(dstr_get(s->dstr, num - 1), 92)))
			s->is_quote = s->is_quote ^ 1;